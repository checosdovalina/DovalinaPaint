import { users, type User, type InsertUser, InsertClient, Client, clients, Project, projects, InsertProject, Quote, quotes, InsertQuote, ServiceOrder, serviceOrders, InsertServiceOrder, Staff, staff, InsertStaff, Activity, activities, InsertActivity, subcontractors, Subcontractor, InsertSubcontractor, invoices, Invoice, InsertInvoice, suppliers, Supplier, InsertSupplier, payments, Payment, InsertPayment, purchaseOrders, PurchaseOrder, InsertPurchaseOrder, purchaseOrderItems, PurchaseOrderItem, InsertPurchaseOrderItem } from "@shared/schema";
import createMemoryStore from "memorystore";
import session from "express-session";
import { db } from "./db";
import { eq, and, desc } from "drizzle-orm";
import connectPg from "connect-pg-simple";
import { pool } from "./db";

// Storage interface
export interface IStorage {
  // User methods
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  
  // Client methods
  getClients(): Promise<Client[]>;
  getClient(id: number): Promise<Client | undefined>;
  createClient(client: InsertClient): Promise<Client>;
  updateClient(id: number, client: Partial<InsertClient>): Promise<Client | undefined>;
  deleteClient(id: number): Promise<boolean>;
  
  // Project methods
  getProjects(): Promise<Project[]>;
  getProject(id: number): Promise<Project | undefined>;
  getProjectsByClient(clientId: number): Promise<Project[]>;
  getProjectsByStatus(status: string): Promise<Project[]>;
  createProject(project: InsertProject): Promise<Project>;
  updateProject(id: number, project: Partial<InsertProject>): Promise<Project | undefined>;
  deleteProject(id: number): Promise<boolean>;
  
  // Quote methods
  getQuotes(): Promise<Quote[]>;
  getQuote(id: number): Promise<Quote | undefined>;
  getQuoteByProject(projectId: number): Promise<Quote | undefined>;
  createQuote(quote: InsertQuote): Promise<Quote>;
  updateQuote(id: number, quote: Partial<InsertQuote>): Promise<Quote | undefined>;
  deleteQuote(id: number): Promise<boolean>;
  
  // Subcontractor methods
  getSubcontractors(): Promise<Subcontractor[]>;
  getSubcontractor(id: number): Promise<Subcontractor | undefined>;
  createSubcontractor(subcontractor: InsertSubcontractor): Promise<Subcontractor>;
  updateSubcontractor(id: number, subcontractor: Partial<InsertSubcontractor>): Promise<Subcontractor | undefined>;
  deleteSubcontractor(id: number): Promise<boolean>;
  
  // Supplier methods
  getSuppliers(): Promise<Supplier[]>;
  getSupplier(id: number): Promise<Supplier | undefined>;
  getSuppliersByCategory(category: string): Promise<Supplier[]>;
  createSupplier(supplier: InsertSupplier): Promise<Supplier>;
  updateSupplier(id: number, supplier: Partial<InsertSupplier>): Promise<Supplier | undefined>;
  deleteSupplier(id: number): Promise<boolean>;
  
  // Service Order methods
  getServiceOrders(): Promise<ServiceOrder[]>;
  getServiceOrder(id: number): Promise<ServiceOrder | undefined>;
  getServiceOrdersByProject(projectId: number): Promise<ServiceOrder[]>;
  createServiceOrder(serviceOrder: InsertServiceOrder): Promise<ServiceOrder>;
  updateServiceOrder(id: number, serviceOrder: Partial<InsertServiceOrder>): Promise<ServiceOrder | undefined>;
  deleteServiceOrder(id: number): Promise<boolean>;
  
  // Staff methods
  getStaff(): Promise<Staff[]>;
  getStaffMember(id: number): Promise<Staff | undefined>;
  createStaffMember(staff: InsertStaff): Promise<Staff>;
  updateStaffMember(id: number, staff: Partial<InsertStaff>): Promise<Staff | undefined>;
  deleteStaffMember(id: number): Promise<boolean>;
  
  // Activity methods
  getActivities(): Promise<Activity[]>;
  getActivity(id: number): Promise<Activity | undefined>;
  getActivitiesByProject(projectId: number): Promise<Activity[]>;
  getActivitiesByClient(clientId: number): Promise<Activity[]>;
  getActivitiesByUser(userId: number): Promise<Activity[]>;
  createActivity(activity: InsertActivity): Promise<Activity>;
  
  // Invoice methods
  getInvoices(): Promise<Invoice[]>;
  getInvoice(id: number): Promise<Invoice | undefined>;
  getInvoicesByProject(projectId: number): Promise<Invoice[]>;
  getInvoicesByClient(clientId: number): Promise<Invoice[]>;
  getInvoicesByStatus(status: string): Promise<Invoice[]>;
  createInvoice(invoice: InsertInvoice): Promise<Invoice>;
  updateInvoice(id: number, invoice: Partial<InsertInvoice>): Promise<Invoice | undefined>;
  deleteInvoice(id: number): Promise<boolean>;
  
  // Payment methods
  getPayments(): Promise<Payment[]>;
  getPayment(id: number): Promise<Payment | undefined>;
  getPaymentsByProject(projectId: number): Promise<Payment[]>;
  getPaymentsByRecipient(type: string, id: number): Promise<Payment[]>;
  getPaymentsByStatus(status: string): Promise<Payment[]>;
  createPayment(payment: InsertPayment): Promise<Payment>;
  updatePayment(id: number, payment: Partial<InsertPayment>): Promise<Payment | undefined>;
  deletePayment(id: number): Promise<boolean>;
  
  // Purchase Order methods
  getPurchaseOrders(): Promise<PurchaseOrder[]>;
  getPurchaseOrder(id: number): Promise<PurchaseOrder | undefined>;
  getPurchaseOrdersBySupplier(supplierId: number): Promise<PurchaseOrder[]>;
  getPurchaseOrdersByProject(projectId: number): Promise<PurchaseOrder[]>;
  getPurchaseOrdersByStatus(status: string): Promise<PurchaseOrder[]>;
  createPurchaseOrder(purchaseOrder: InsertPurchaseOrder): Promise<PurchaseOrder>;
  updatePurchaseOrder(id: number, purchaseOrder: Partial<InsertPurchaseOrder>): Promise<PurchaseOrder | undefined>;
  deletePurchaseOrder(id: number): Promise<boolean>;
  
  // Purchase Order Items methods
  getPurchaseOrderItems(purchaseOrderId: number): Promise<PurchaseOrderItem[]>;
  getPurchaseOrderItem(id: number): Promise<PurchaseOrderItem | undefined>;
  createPurchaseOrderItem(item: InsertPurchaseOrderItem): Promise<PurchaseOrderItem>;
  updatePurchaseOrderItem(id: number, item: Partial<InsertPurchaseOrderItem>): Promise<PurchaseOrderItem | undefined>;
  deletePurchaseOrderItem(id: number): Promise<boolean>;
  
  // Session store
  sessionStore: any;
}

export class DatabaseStorage implements IStorage {
  sessionStore: any;

  constructor() {
    const PostgresSessionStore = connectPg(session);
    this.sessionStore = new PostgresSessionStore({
      pool,
      createTableIfMissing: true
    });
    
    // Initialize admin user if needed (will run on startup)
    this.initializeAdminUser();
  }
  
  // Subcontractor methods
  async getSubcontractors(): Promise<Subcontractor[]> {
    try {
      return await db.select().from(subcontractors);
    } catch (error) {
      console.error("Error fetching subcontractors:", error);
      return [];
    }
  }
  
  async getSubcontractor(id: number): Promise<Subcontractor | undefined> {
    try {
      const [subcontractor] = await db.select().from(subcontractors).where(eq(subcontractors.id, id));
      return subcontractor;
    } catch (error) {
      console.error("Error fetching subcontractor:", error);
      return undefined;
    }
  }
  
  async createSubcontractor(subcontractor: InsertSubcontractor): Promise<Subcontractor> {
    try {
      const [newSubcontractor] = await db.insert(subcontractors).values(subcontractor).returning();
      return newSubcontractor;
    } catch (error) {
      console.error("Error creating subcontractor:", error);
      throw error;
    }
  }
  
  async updateSubcontractor(id: number, subcontractor: Partial<InsertSubcontractor>): Promise<Subcontractor | undefined> {
    try {
      const [updatedSubcontractor] = await db
        .update(subcontractors)
        .set(subcontractor)
        .where(eq(subcontractors.id, id))
        .returning();
      return updatedSubcontractor;
    } catch (error) {
      console.error("Error updating subcontractor:", error);
      return undefined;
    }
  }
  
  async deleteSubcontractor(id: number): Promise<boolean> {
    try {
      await db.delete(subcontractors).where(eq(subcontractors.id, id));
      return true;
    } catch (error) {
      console.error("Error deleting subcontractor:", error);
      return false;
    }
  }
  
  private async initializeAdminUser() {
    try {
      // Check if we have any users in the system
      const existingUsers = await db.select().from(users);
      
      if (existingUsers.length === 0) {
        // Create predefined hashed passwords using our simplified hashing logic
        const hashedPassword = "hashed_password123";
        
        // Create default admin users with the required usernames and passwords
        await this.createUser({
          username: "sdovalina",
          password: hashedPassword,
          name: "Santiago Dovalina",
          role: "superadmin"
        });
        
        await this.createUser({
          username: "alexdovalina",
          password: hashedPassword,
          name: "Alex Dovalina",
          role: "admin"
        });
        
        await this.createUser({
          username: "dianashindledecker",
          password: hashedPassword,
          name: "Diana Shindledecker",
          role: "admin"
        });
        
        await this.createUser({
          username: "davidshindledecker",
          password: hashedPassword,
          name: "David Shindledecker",
          role: "admin"
        });
        
        console.log("Created all admin users");
        
        // Add some initial staff members
        await this.initializeSampleStaff();
      }
    } catch (error) {
      console.error("Error initializing admin users:", error);
    }
  }
  
  // Initialize sample staff members if needed
  private async initializeSampleStaff() {
    try {
      const existingStaff = await this.getStaff();
      
      if (existingStaff.length === 0) {
        await this.createStaffMember({
          name: "Alex Dovalina",
          role: "Painter",
          email: "alex@dovalinapainting.com",
          phone: "555-1234",
          availability: "available",
          skills: ["interior", "exterior"],
          avatar: "/worker1.svg"
        });
        
        await this.createStaffMember({
          name: "Diana Shindledecker",
          role: "Project Manager",
          email: "diana@dovalinapainting.com",
          phone: "555-5678",
          availability: "available",
          skills: ["management", "client relations"],
          avatar: "/worker2.svg"
        });
        
        await this.createStaffMember({
          name: "David Shindledecker",
          role: "Painter",
          email: "david@dovalinapainting.com",
          phone: "555-9012",
          availability: "available",
          skills: ["commercial", "industrial"],
          avatar: "/worker3.svg"
        });
        
        console.log("Created sample staff members");
      }
    } catch (error) {
      console.error("Error initializing sample staff:", error);
    }
  }

  // User methods
  async getUser(id: number): Promise<User | undefined> {
    try {
      const [user] = await db.select().from(users).where(eq(users.id, id));
      return user;
    } catch (error) {
      console.error("Error fetching user:", error);
      return undefined;
    }
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    try {
      const [user] = await db.select().from(users).where(eq(users.username, username));
      return user;
    } catch (error) {
      console.error("Error fetching user by username:", error);
      return undefined;
    }
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    try {
      const [user] = await db.insert(users).values(insertUser).returning();
      return user;
    } catch (error) {
      console.error("Error creating user:", error);
      throw error;
    }
  }
  
  // Client methods
  async getClients(): Promise<Client[]> {
    try {
      return await db.select().from(clients);
    } catch (error) {
      console.error("Error fetching clients:", error);
      return [];
    }
  }
  
  async getClient(id: number): Promise<Client | undefined> {
    try {
      const [client] = await db.select().from(clients).where(eq(clients.id, id));
      return client;
    } catch (error) {
      console.error("Error fetching client:", error);
      return undefined;
    }
  }
  
  async createClient(client: InsertClient): Promise<Client> {
    try {
      const [newClient] = await db.insert(clients).values(client).returning();
      return newClient;
    } catch (error) {
      console.error("Error creating client:", error);
      throw error;
    }
  }
  
  async updateClient(id: number, client: Partial<InsertClient>): Promise<Client | undefined> {
    try {
      const [updatedClient] = await db
        .update(clients)
        .set(client)
        .where(eq(clients.id, id))
        .returning();
      return updatedClient;
    } catch (error) {
      console.error("Error updating client:", error);
      return undefined;
    }
  }
  
  async deleteClient(id: number): Promise<boolean> {
    try {
      const result = await db.delete(clients).where(eq(clients.id, id));
      return true;
    } catch (error) {
      console.error("Error deleting client:", error);
      return false;
    }
  }
  
  // Project methods
  async getProjects(): Promise<Project[]> {
    try {
      return await db.select().from(projects);
    } catch (error) {
      console.error("Error fetching projects:", error);
      return [];
    }
  }
  
  async getProject(id: number): Promise<Project | undefined> {
    try {
      const [project] = await db.select().from(projects).where(eq(projects.id, id));
      return project;
    } catch (error) {
      console.error("Error fetching project:", error);
      return undefined;
    }
  }
  
  async getProjectsByClient(clientId: number): Promise<Project[]> {
    try {
      return await db.select().from(projects).where(eq(projects.clientId, clientId));
    } catch (error) {
      console.error("Error fetching projects by client:", error);
      return [];
    }
  }
  
  async getProjectsByStatus(status: string): Promise<Project[]> {
    try {
      return await db.select().from(projects).where(eq(projects.status, status));
    } catch (error) {
      console.error("Error fetching projects by status:", error);
      return [];
    }
  }
  
  async createProject(project: InsertProject): Promise<Project> {
    try {
      const [newProject] = await db.insert(projects).values(project).returning();
      return newProject;
    } catch (error) {
      console.error("Error creating project:", error);
      throw error;
    }
  }
  
  async updateProject(id: number, project: Partial<InsertProject>): Promise<Project | undefined> {
    try {
      const [updatedProject] = await db
        .update(projects)
        .set(project)
        .where(eq(projects.id, id))
        .returning();
      return updatedProject;
    } catch (error) {
      console.error("Error updating project:", error);
      return undefined;
    }
  }
  
  async deleteProject(id: number): Promise<boolean> {
    try {
      await db.delete(projects).where(eq(projects.id, id));
      return true;
    } catch (error) {
      console.error("Error deleting project:", error);
      return false;
    }
  }
  
  // Quote methods
  async getQuotes(): Promise<Quote[]> {
    try {
      return await db.select().from(quotes);
    } catch (error) {
      console.error("Error fetching quotes:", error);
      return [];
    }
  }
  
  async getQuote(id: number): Promise<Quote | undefined> {
    try {
      const [quote] = await db.select().from(quotes).where(eq(quotes.id, id));
      return quote;
    } catch (error) {
      console.error("Error fetching quote:", error);
      return undefined;
    }
  }
  
  async getQuoteByProject(projectId: number): Promise<Quote | undefined> {
    try {
      const [quote] = await db.select().from(quotes).where(eq(quotes.projectId, projectId));
      return quote;
    } catch (error) {
      console.error("Error fetching quote by project:", error);
      return undefined;
    }
  }
  
  async createQuote(quote: InsertQuote): Promise<Quote> {
    try {
      const [newQuote] = await db.insert(quotes).values(quote).returning();
      return newQuote;
    } catch (error) {
      console.error("Error creating quote:", error);
      throw error;
    }
  }
  
  async updateQuote(id: number, quote: Partial<InsertQuote>): Promise<Quote | undefined> {
    try {
      const [updatedQuote] = await db
        .update(quotes)
        .set(quote)
        .where(eq(quotes.id, id))
        .returning();
      return updatedQuote;
    } catch (error) {
      console.error("Error updating quote:", error);
      return undefined;
    }
  }
  
  async deleteQuote(id: number): Promise<boolean> {
    try {
      await db.delete(quotes).where(eq(quotes.id, id));
      return true;
    } catch (error) {
      console.error("Error deleting quote:", error);
      return false;
    }
  }
  
  // Service Order methods
  async getServiceOrders(): Promise<ServiceOrder[]> {
    try {
      return await db.select().from(serviceOrders);
    } catch (error) {
      console.error("Error fetching service orders:", error);
      return [];
    }
  }
  
  async getServiceOrder(id: number): Promise<ServiceOrder | undefined> {
    try {
      const [serviceOrder] = await db.select().from(serviceOrders).where(eq(serviceOrders.id, id));
      return serviceOrder;
    } catch (error) {
      console.error("Error fetching service order:", error);
      return undefined;
    }
  }
  
  async getServiceOrdersByProject(projectId: number): Promise<ServiceOrder[]> {
    try {
      return await db.select().from(serviceOrders).where(eq(serviceOrders.projectId, projectId));
    } catch (error) {
      console.error("Error fetching service orders by project:", error);
      return [];
    }
  }
  
  async createServiceOrder(serviceOrder: InsertServiceOrder): Promise<ServiceOrder> {
    try {
      const [newServiceOrder] = await db.insert(serviceOrders).values(serviceOrder).returning();
      return newServiceOrder;
    } catch (error) {
      console.error("Error creating service order:", error);
      throw error;
    }
  }
  
  async updateServiceOrder(id: number, serviceOrder: Partial<InsertServiceOrder>): Promise<ServiceOrder | undefined> {
    try {
      const [updatedServiceOrder] = await db
        .update(serviceOrders)
        .set(serviceOrder)
        .where(eq(serviceOrders.id, id))
        .returning();
      return updatedServiceOrder;
    } catch (error) {
      console.error("Error updating service order:", error);
      return undefined;
    }
  }
  
  async deleteServiceOrder(id: number): Promise<boolean> {
    try {
      await db.delete(serviceOrders).where(eq(serviceOrders.id, id));
      return true;
    } catch (error) {
      console.error("Error deleting service order:", error);
      return false;
    }
  }
  
  // Staff methods
  async getStaff(): Promise<Staff[]> {
    try {
      return await db.select().from(staff);
    } catch (error) {
      console.error("Error fetching staff:", error);
      return [];
    }
  }
  
  async getStaffMember(id: number): Promise<Staff | undefined> {
    try {
      const [staffMember] = await db.select().from(staff).where(eq(staff.id, id));
      return staffMember;
    } catch (error) {
      console.error("Error fetching staff member:", error);
      return undefined;
    }
  }
  
  async createStaffMember(staffMember: InsertStaff): Promise<Staff> {
    try {
      const [newStaffMember] = await db.insert(staff).values(staffMember).returning();
      return newStaffMember;
    } catch (error) {
      console.error("Error creating staff member:", error);
      throw error;
    }
  }
  
  async updateStaffMember(id: number, staffMember: Partial<InsertStaff>): Promise<Staff | undefined> {
    try {
      const [updatedStaffMember] = await db
        .update(staff)
        .set(staffMember)
        .where(eq(staff.id, id))
        .returning();
      return updatedStaffMember;
    } catch (error) {
      console.error("Error updating staff member:", error);
      return undefined;
    }
  }
  
  async deleteStaffMember(id: number): Promise<boolean> {
    try {
      await db.delete(staff).where(eq(staff.id, id));
      return true;
    } catch (error) {
      console.error("Error deleting staff member:", error);
      return false;
    }
  }
  
  // Activity methods
  async getActivities(): Promise<Activity[]> {
    try {
      return await db.select().from(activities).orderBy(desc(activities.createdAt));
    } catch (error) {
      console.error("Error fetching activities:", error);
      return [];
    }
  }
  
  async getActivity(id: number): Promise<Activity | undefined> {
    try {
      const [activity] = await db.select().from(activities).where(eq(activities.id, id));
      return activity;
    } catch (error) {
      console.error("Error fetching activity:", error);
      return undefined;
    }
  }
  
  async getActivitiesByProject(projectId: number): Promise<Activity[]> {
    try {
      return await db
        .select()
        .from(activities)
        .where(eq(activities.projectId, projectId))
        .orderBy(desc(activities.createdAt));
    } catch (error) {
      console.error("Error fetching activities by project:", error);
      return [];
    }
  }
  
  async getActivitiesByClient(clientId: number): Promise<Activity[]> {
    try {
      return await db
        .select()
        .from(activities)
        .where(eq(activities.clientId, clientId))
        .orderBy(desc(activities.createdAt));
    } catch (error) {
      console.error("Error fetching activities by client:", error);
      return [];
    }
  }
  
  async getActivitiesByUser(userId: number): Promise<Activity[]> {
    try {
      return await db
        .select()
        .from(activities)
        .where(eq(activities.userId, userId))
        .orderBy(desc(activities.createdAt));
    } catch (error) {
      console.error("Error fetching activities by user:", error);
      return [];
    }
  }
  
  async createActivity(activity: InsertActivity): Promise<Activity> {
    try {
      const [newActivity] = await db.insert(activities).values(activity).returning();
      return newActivity;
    } catch (error) {
      console.error("Error creating activity:", error);
      throw error;
    }
  }

  // Invoice methods
  async getInvoices(): Promise<Invoice[]> {
    try {
      return await db.select().from(invoices).orderBy(desc(invoices.createdAt));
    } catch (error) {
      console.error("Error fetching invoices:", error);
      return [];
    }
  }
  
  async getInvoice(id: number): Promise<Invoice | undefined> {
    try {
      const [invoice] = await db.select().from(invoices).where(eq(invoices.id, id));
      return invoice;
    } catch (error) {
      console.error("Error fetching invoice:", error);
      return undefined;
    }
  }
  
  async getInvoicesByProject(projectId: number): Promise<Invoice[]> {
    try {
      return await db.select().from(invoices).where(eq(invoices.projectId, projectId));
    } catch (error) {
      console.error("Error fetching invoices by project:", error);
      return [];
    }
  }
  
  async getInvoicesByClient(clientId: number): Promise<Invoice[]> {
    try {
      return await db.select().from(invoices).where(eq(invoices.clientId, clientId));
    } catch (error) {
      console.error("Error fetching invoices by client:", error);
      return [];
    }
  }
  
  async getInvoicesByStatus(status: string): Promise<Invoice[]> {
    try {
      return await db.select().from(invoices).where(eq(invoices.status, status));
    } catch (error) {
      console.error("Error fetching invoices by status:", error);
      return [];
    }
  }
  
  async createInvoice(invoice: InsertInvoice): Promise<Invoice> {
    try {
      const [newInvoice] = await db.insert(invoices).values(invoice).returning();
      return newInvoice;
    } catch (error) {
      console.error("Error creating invoice:", error);
      throw error;
    }
  }
  
  async updateInvoice(id: number, invoice: Partial<InsertInvoice>): Promise<Invoice | undefined> {
    try {
      const [updatedInvoice] = await db
        .update(invoices)
        .set(invoice)
        .where(eq(invoices.id, id))
        .returning();
      return updatedInvoice;
    } catch (error) {
      console.error("Error updating invoice:", error);
      return undefined;
    }
  }
  
  async deleteInvoice(id: number): Promise<boolean> {
    try {
      await db.delete(invoices).where(eq(invoices.id, id));
      return true;
    } catch (error) {
      console.error("Error deleting invoice:", error);
      return false;
    }
  }
  
  // Supplier methods
  async getSuppliers(): Promise<Supplier[]> {
    try {
      return await db.select().from(suppliers);
    } catch (error) {
      console.error("Error fetching suppliers:", error);
      return [];
    }
  }
  
  async getSupplier(id: number): Promise<Supplier | undefined> {
    try {
      const [supplier] = await db.select().from(suppliers).where(eq(suppliers.id, id));
      return supplier;
    } catch (error) {
      console.error("Error fetching supplier:", error);
      return undefined;
    }
  }
  
  async getSuppliersByCategory(category: string): Promise<Supplier[]> {
    try {
      return await db.select().from(suppliers).where(eq(suppliers.category, category));
    } catch (error) {
      console.error("Error fetching suppliers by category:", error);
      return [];
    }
  }
  
  async createSupplier(supplier: InsertSupplier): Promise<Supplier> {
    try {
      const [newSupplier] = await db.insert(suppliers).values(supplier).returning();
      return newSupplier;
    } catch (error) {
      console.error("Error creating supplier:", error);
      throw error;
    }
  }
  
  async updateSupplier(id: number, supplier: Partial<InsertSupplier>): Promise<Supplier | undefined> {
    try {
      const [updatedSupplier] = await db
        .update(suppliers)
        .set(supplier)
        .where(eq(suppliers.id, id))
        .returning();
      return updatedSupplier;
    } catch (error) {
      console.error("Error updating supplier:", error);
      return undefined;
    }
  }
  
  async deleteSupplier(id: number): Promise<boolean> {
    try {
      await db.delete(suppliers).where(eq(suppliers.id, id));
      return true;
    } catch (error) {
      console.error("Error deleting supplier:", error);
      return false;
    }
  }
  
  // Payment methods
  async getPayments(): Promise<Payment[]> {
    try {
      return await db.select().from(payments).orderBy(desc(payments.date));
    } catch (error) {
      console.error("Error fetching payments:", error);
      return [];
    }
  }
  
  async getPayment(id: number): Promise<Payment | undefined> {
    try {
      const [payment] = await db.select().from(payments).where(eq(payments.id, id));
      return payment;
    } catch (error) {
      console.error("Error fetching payment:", error);
      return undefined;
    }
  }
  
  async getPaymentsByProject(projectId: number): Promise<Payment[]> {
    try {
      return await db.select().from(payments).where(eq(payments.projectId, projectId)).orderBy(desc(payments.date));
    } catch (error) {
      console.error("Error fetching payments by project:", error);
      return [];
    }
  }
  
  async getPaymentsByRecipient(type: string, id: number): Promise<Payment[]> {
    try {
      return await db.select().from(payments)
        .where(and(
          eq(payments.recipientType, type),
          eq(payments.recipientId, id)
        ))
        .orderBy(desc(payments.date));
    } catch (error) {
      console.error("Error fetching payments by recipient:", error);
      return [];
    }
  }
  
  async getPaymentsByStatus(status: string): Promise<Payment[]> {
    try {
      return await db.select().from(payments).where(eq(payments.status, status)).orderBy(desc(payments.date));
    } catch (error) {
      console.error("Error fetching payments by status:", error);
      return [];
    }
  }
  
  async createPayment(payment: InsertPayment): Promise<Payment> {
    try {
      const [newPayment] = await db.insert(payments).values(payment).returning();
      return newPayment;
    } catch (error) {
      console.error("Error creating payment:", error);
      throw error;
    }
  }
  
  async updatePayment(id: number, payment: Partial<InsertPayment>): Promise<Payment | undefined> {
    try {
      const [updatedPayment] = await db
        .update(payments)
        .set(payment)
        .where(eq(payments.id, id))
        .returning();
      return updatedPayment;
    } catch (error) {
      console.error("Error updating payment:", error);
      return undefined;
    }
  }
  
  async deletePayment(id: number): Promise<boolean> {
    try {
      await db.delete(payments).where(eq(payments.id, id));
      return true;
    } catch (error) {
      console.error("Error deleting payment:", error);
      return false;
    }
  }
}

export class MemStorage implements IStorage {
  // This class is kept for compatibility but is no longer used
  private users: Map<number, User> = new Map();
  private clients: Map<number, Client> = new Map();
  private projects: Map<number, Project> = new Map();
  private quotes: Map<number, Quote> = new Map();
  private serviceOrders: Map<number, ServiceOrder> = new Map();
  private staffMembers: Map<number, Staff> = new Map();
  private activitiesLog: Map<number, Activity> = new Map();
  private subcontractors: Map<number, Subcontractor> = new Map();
  private suppliers: Map<number, Supplier> = new Map();
  private purchaseOrders: Map<number, PurchaseOrder> = new Map();
  private purchaseOrderItems: Map<number, PurchaseOrderItem> = new Map();
  
  sessionStore: any;
  
  constructor() {
    const MemoryStore = createMemoryStore(session);
    this.sessionStore = new MemoryStore({
      checkPeriod: 86400000
    });
  }
  
  // Subcontractor methods
  async getSubcontractors(): Promise<Subcontractor[]> { return []; }
  async getSubcontractor(id: number): Promise<Subcontractor | undefined> { return undefined; }
  async createSubcontractor(subcontractor: InsertSubcontractor): Promise<Subcontractor> { throw new Error("Not implemented"); }
  async updateSubcontractor(id: number, subcontractor: Partial<InsertSubcontractor>): Promise<Subcontractor | undefined> { return undefined; }
  async deleteSubcontractor(id: number): Promise<boolean> { return false; }
  
  // User methods
  async getUser(id: number): Promise<User | undefined> { return undefined; }
  async getUserByUsername(username: string): Promise<User | undefined> { return undefined; }
  async createUser(user: InsertUser): Promise<User> { throw new Error("Not implemented"); }
  
  // Client methods
  async getClients(): Promise<Client[]> { return []; }
  async getClient(id: number): Promise<Client | undefined> { return undefined; }
  async createClient(client: InsertClient): Promise<Client> { throw new Error("Not implemented"); }
  async updateClient(id: number, client: Partial<InsertClient>): Promise<Client | undefined> { return undefined; }
  async deleteClient(id: number): Promise<boolean> { return false; }
  
  // Project methods
  async getProjects(): Promise<Project[]> { return []; }
  async getProject(id: number): Promise<Project | undefined> { return undefined; }
  async getProjectsByClient(clientId: number): Promise<Project[]> { return []; }
  async getProjectsByStatus(status: string): Promise<Project[]> { return []; }
  async createProject(project: InsertProject): Promise<Project> { throw new Error("Not implemented"); }
  async updateProject(id: number, project: Partial<InsertProject>): Promise<Project | undefined> { return undefined; }
  async deleteProject(id: number): Promise<boolean> { return false; }
  
  // Quote methods
  async getQuotes(): Promise<Quote[]> { return []; }
  async getQuote(id: number): Promise<Quote | undefined> { return undefined; }
  async getQuoteByProject(projectId: number): Promise<Quote | undefined> { return undefined; }
  async createQuote(quote: InsertQuote): Promise<Quote> { throw new Error("Not implemented"); }
  async updateQuote(id: number, quote: Partial<InsertQuote>): Promise<Quote | undefined> { return undefined; }
  async deleteQuote(id: number): Promise<boolean> { return false; }
  
  // Service Order methods
  async getServiceOrders(): Promise<ServiceOrder[]> { return []; }
  async getServiceOrder(id: number): Promise<ServiceOrder | undefined> { return undefined; }
  async getServiceOrdersByProject(projectId: number): Promise<ServiceOrder[]> { return []; }
  async createServiceOrder(serviceOrder: InsertServiceOrder): Promise<ServiceOrder> { throw new Error("Not implemented"); }
  async updateServiceOrder(id: number, serviceOrder: Partial<InsertServiceOrder>): Promise<ServiceOrder | undefined> { return undefined; }
  async deleteServiceOrder(id: number): Promise<boolean> { return false; }
  
  // Staff methods
  async getStaff(): Promise<Staff[]> { return []; }
  async getStaffMember(id: number): Promise<Staff | undefined> { return undefined; }
  async createStaffMember(staff: InsertStaff): Promise<Staff> { throw new Error("Not implemented"); }
  async updateStaffMember(id: number, staff: Partial<InsertStaff>): Promise<Staff | undefined> { return undefined; }
  async deleteStaffMember(id: number): Promise<boolean> { return false; }
  
  // Activity methods
  async getActivities(): Promise<Activity[]> { return []; }
  async getActivity(id: number): Promise<Activity | undefined> { return undefined; }
  async getActivitiesByProject(projectId: number): Promise<Activity[]> { return []; }
  async getActivitiesByClient(clientId: number): Promise<Activity[]> { return []; }
  async getActivitiesByUser(userId: number): Promise<Activity[]> { return []; }
  async createActivity(activity: InsertActivity): Promise<Activity> { throw new Error("Not implemented"); }
  
  // Invoice methods
  async getInvoices(): Promise<Invoice[]> { return []; }
  async getInvoice(id: number): Promise<Invoice | undefined> { return undefined; }
  async getInvoicesByProject(projectId: number): Promise<Invoice[]> { return []; }
  async getInvoicesByClient(clientId: number): Promise<Invoice[]> { return []; }
  async getInvoicesByStatus(status: string): Promise<Invoice[]> { return []; }
  async createInvoice(invoice: InsertInvoice): Promise<Invoice> { throw new Error("Not implemented"); }
  async updateInvoice(id: number, invoice: Partial<InsertInvoice>): Promise<Invoice | undefined> { return undefined; }
  async deleteInvoice(id: number): Promise<boolean> { return false; }

  // Supplier methods
  async getSuppliers(): Promise<Supplier[]> { return []; }
  async getSupplier(id: number): Promise<Supplier | undefined> { return undefined; }
  async getSuppliersByCategory(category: string): Promise<Supplier[]> { return []; }
  async createSupplier(supplier: InsertSupplier): Promise<Supplier> { throw new Error("Not implemented"); }
  async updateSupplier(id: number, supplier: Partial<InsertSupplier>): Promise<Supplier | undefined> { return undefined; }
  async deleteSupplier(id: number): Promise<boolean> { return false; }
  
  // Payment methods
  async getPayments(): Promise<Payment[]> { return []; }
  async getPayment(id: number): Promise<Payment | undefined> { return undefined; }
  async getPaymentsByProject(projectId: number): Promise<Payment[]> { return []; }
  async getPaymentsByRecipient(type: string, id: number): Promise<Payment[]> { return []; }
  async getPaymentsByStatus(status: string): Promise<Payment[]> { return []; }
  async createPayment(payment: InsertPayment): Promise<Payment> { throw new Error("Not implemented"); }
  async updatePayment(id: number, payment: Partial<InsertPayment>): Promise<Payment | undefined> { return undefined; }
  async deletePayment(id: number): Promise<boolean> { return false; }
  
  // Purchase Order methods
  async getPurchaseOrders(): Promise<PurchaseOrder[]> { return []; }
  async getPurchaseOrder(id: number): Promise<PurchaseOrder | undefined> { return undefined; }
  async getPurchaseOrdersBySupplier(supplierId: number): Promise<PurchaseOrder[]> { return []; }
  async getPurchaseOrdersByProject(projectId: number): Promise<PurchaseOrder[]> { return []; }
  async getPurchaseOrdersByStatus(status: string): Promise<PurchaseOrder[]> { return []; }
  async createPurchaseOrder(purchaseOrder: InsertPurchaseOrder): Promise<PurchaseOrder> { throw new Error("Not implemented"); }
  async updatePurchaseOrder(id: number, purchaseOrder: Partial<InsertPurchaseOrder>): Promise<PurchaseOrder | undefined> { return undefined; }
  async deletePurchaseOrder(id: number): Promise<boolean> { return false; }
  
  // Purchase Order Items methods
  async getPurchaseOrderItems(purchaseOrderId: number): Promise<PurchaseOrderItem[]> { return []; }
  async getPurchaseOrderItem(id: number): Promise<PurchaseOrderItem | undefined> { return undefined; }
  async createPurchaseOrderItem(item: InsertPurchaseOrderItem): Promise<PurchaseOrderItem> { throw new Error("Not implemented"); }
  async updatePurchaseOrderItem(id: number, item: Partial<InsertPurchaseOrderItem>): Promise<PurchaseOrderItem | undefined> { return undefined; }
  async deletePurchaseOrderItem(id: number): Promise<boolean> { return false; }
}
    try {
      return await db.select().from(purchaseOrders);
    } catch (error) {
      console.error("Error fetching purchase orders:", error);
      return [];
    }
  }
  
  async getPurchaseOrder(id: number): Promise<PurchaseOrder | undefined> {
    try {
      const [purchaseOrder] = await db.select().from(purchaseOrders).where(eq(purchaseOrders.id, id));
      return purchaseOrder;
    } catch (error) {
      console.error("Error fetching purchase order:", error);
      return undefined;
    }
  }
  
  async getPurchaseOrdersBySupplier(supplierId: number): Promise<PurchaseOrder[]> {
    try {
      return await db.select().from(purchaseOrders).where(eq(purchaseOrders.supplierId, supplierId));
    } catch (error) {
      console.error("Error fetching purchase orders by supplier:", error);
      return [];
    }
  }
  
  async getPurchaseOrdersByProject(projectId: number): Promise<PurchaseOrder[]> {
    try {
      return await db.select().from(purchaseOrders).where(eq(purchaseOrders.projectId, projectId));
    } catch (error) {
      console.error("Error fetching purchase orders by project:", error);
      return [];
    }
  }
  
  async getPurchaseOrdersByStatus(status: string): Promise<PurchaseOrder[]> {
    try {
      return await db.select().from(purchaseOrders).where(eq(purchaseOrders.status, status));
    } catch (error) {
      console.error("Error fetching purchase orders by status:", error);
      return [];
    }
  }
  
  async createPurchaseOrder(purchaseOrder: InsertPurchaseOrder): Promise<PurchaseOrder> {
    try {
      const [newPurchaseOrder] = await db.insert(purchaseOrders).values(purchaseOrder).returning();
      return newPurchaseOrder;
    } catch (error) {
      console.error("Error creating purchase order:", error);
      throw error;
    }
  }
  
  async updatePurchaseOrder(id: number, purchaseOrder: Partial<InsertPurchaseOrder>): Promise<PurchaseOrder | undefined> {
    try {
      const [updatedPurchaseOrder] = await db
        .update(purchaseOrders)
        .set({
          ...purchaseOrder,
          updatedAt: new Date()
        })
        .where(eq(purchaseOrders.id, id))
        .returning();
      return updatedPurchaseOrder;
    } catch (error) {
      console.error("Error updating purchase order:", error);
      return undefined;
    }
  }
  
  async deletePurchaseOrder(id: number): Promise<boolean> {
    try {
      await db.delete(purchaseOrders).where(eq(purchaseOrders.id, id));
      return true;
    } catch (error) {
      console.error("Error deleting purchase order:", error);
      return false;
    }
  }
  
  // Purchase Order Items methods
  async getPurchaseOrderItems(purchaseOrderId: number): Promise<PurchaseOrderItem[]> {
    try {
      return await db
        .select()
        .from(purchaseOrderItems)
        .where(eq(purchaseOrderItems.purchaseOrderId, purchaseOrderId));
    } catch (error) {
      console.error("Error fetching purchase order items:", error);
      return [];
    }
  }
  
  async getPurchaseOrderItem(id: number): Promise<PurchaseOrderItem | undefined> {
    try {
      const [item] = await db
        .select()
        .from(purchaseOrderItems)
        .where(eq(purchaseOrderItems.id, id));
      return item;
    } catch (error) {
      console.error("Error fetching purchase order item:", error);
      return undefined;
    }
  }
  
  async createPurchaseOrderItem(item: InsertPurchaseOrderItem): Promise<PurchaseOrderItem> {
    try {
      const [newItem] = await db
        .insert(purchaseOrderItems)
        .values(item)
        .returning();
      
      // Update the total amount of the parent purchase order
      const items = await this.getPurchaseOrderItems(item.purchaseOrderId);
      const totalAmount = items.reduce((sum, item) => sum + Number(item.totalPrice), 0);
      
      await this.updatePurchaseOrder(item.purchaseOrderId, {
        totalAmount: totalAmount.toString()
      });
      
      return newItem;
    } catch (error) {
      console.error("Error creating purchase order item:", error);
      throw error;
    }
  }
  
  async updatePurchaseOrderItem(id: number, item: Partial<InsertPurchaseOrderItem>): Promise<PurchaseOrderItem | undefined> {
    try {
      const [updatedItem] = await db
        .update(purchaseOrderItems)
        .set({
          ...item,
          updatedAt: new Date()
        })
        .where(eq(purchaseOrderItems.id, id))
        .returning();
      
      // If the price changed, update the total amount of the parent purchase order
      if (item.totalPrice || item.unitPrice || item.quantity) {
        const items = await this.getPurchaseOrderItems(updatedItem.purchaseOrderId);
        const totalAmount = items.reduce((sum, item) => sum + Number(item.totalPrice), 0);
        
        await this.updatePurchaseOrder(updatedItem.purchaseOrderId, {
          totalAmount: totalAmount.toString()
        });
      }
      
      return updatedItem;
    } catch (error) {
      console.error("Error updating purchase order item:", error);
      return undefined;
    }
  }
  
  async deletePurchaseOrderItem(id: number): Promise<boolean> {
    try {
      // Get the item before deleting it to know its parent purchase order
      const item = await this.getPurchaseOrderItem(id);
      if (!item) {
        return false;
      }
      
      // Delete the item
      await db.delete(purchaseOrderItems).where(eq(purchaseOrderItems.id, id));
      
      // Update the total amount of the parent purchase order
      const items = await this.getPurchaseOrderItems(item.purchaseOrderId);
      const totalAmount = items.reduce((sum, item) => sum + Number(item.totalPrice), 0);
      
      await this.updatePurchaseOrder(item.purchaseOrderId, {
        totalAmount: totalAmount.toString()
      });
      
      return true;
    } catch (error) {
      console.error("Error deleting purchase order item:", error);
      return false;
    }
  }
}

export const storage = new DatabaseStorage();
